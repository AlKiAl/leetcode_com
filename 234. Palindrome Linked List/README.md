https://leetcode.com/problems/palindrome-linked-list/description/

https://walkccc.me/LeetCode/problems/0234/

Лакман Макдауэл - Карьера программиста (2020) 

  условие: страница 87, задача 2.6.
  
  решение: страница 223

https://github.com/SkosMartren/leetcode_com/tree/main/206.%20Reverse%20Linked%20List --> https://github.com/SkosMartren/leetcode_com/tree/main/234.%20Palindrome%20Linked%20List
________

[Разбор задачи 234 leetcode.com Palindrome Linked List. Решение на C++](https://www.youtube.com/watch?v=MdcP1e-pnNw)

1->2->3->3->2->1

Чтобы идти с двух сторон и сравнивать - нужно вторую часть списка развернуть.

1->2->3->3<-2<-1

Идём с двух концов одновременно - сравниваем элементы. 
Если нашли различие - ответ "нет".

Неочевидно: по-хорошему нужно вернуть список в то состояние, в каком его передали.

Обсудить с интервьюером, можно ли менять исходный head и будет ли приемлемо, что после результата работы функции head = 1->2->3->3<-2<-1 -- то есть указатели будут изменены 
________

1->2->3->3->2->1->nullptr

| head 	|   	| 1 	| -> 	| 2 	| -> 	| 3 	| -> 	| 3 	| -> 	| 2 	| -> 	| 1 	| -> 	| nullptr 	|
|------	|---	|---	|----	|---	|----	|---	|----	|---	|----	|---	|----	|---	|----	|---------	|

Чтобы идти с двух сторон и сравнивать - нужно вторую часть списка развернуть.

1->2->3->3<-2<-1

|                    	|   	|   	|    	|   	|    	|   	|    	| nullptr   	|    	|   	|    	|   	|
|--------------------	|---	|---	|----	|---	|----	|---	|----	|-----------	|----	|---	|----	|---	|
|                    	|   	|   	|    	|   	|    	|   	|    	| ^ <br> \| 	|    	|   	|    	|   	|
| head after reverse 	|   	| 1 	| -> 	| 2 	| -> 	| 3 	| -> 	| 3         	| <- 	| 2 	| <- 	| 1 	|

________

1->2->3->2->1->nullptr

| head 	|   	| 1 	| -> 	| 2 	|  -> 	| 3 	| -> 	| 2 	| -> 	| 1 	| -> 	| nullptr 	|
|------	|---	|---	|----	|---	| ----	|---	|----	|---	|----	|---	|----	|---------	|

1->2->3<-2<-1
          
|                    	|   	|   	|    	|   	|     	| nullptr   	|    	|   	|    	|   	|
|--------------------	|---	|---	|----	|---	|---- 	|-----------	|----	|---	|----	|---	|
|                    	|   	|   	|    	|   	|     	| ^ <br> \| 	|    	|   	|    	|   	|
| head after reverse 	|   	| 1 	| -> 	| 2 	|  -> 	| 3         	| <- 	| 1 	| <- 	| 2 	|


_________

Комментарий с youtube

отличное решение! Его можно еще немного оптимизировать заменив getLen + forward на 2 указателя один из которых проходит 2 узла вместо одного. Когда этот указатель достигнет конца списка, медленный указатель пройдет лишь половину списка,  а это именно то, что нам нужно.


Я в курсе, что иногда на собеседовании просят написать нахождение середины списка, используя два указателя - быстрый и медленный. Но вот почему это оптимальнее - я не вижу. Какое Ваше мнение на этот счёт? Почему вариант с двумя указателями "лучше", чем getLen+forward?


Это очень хороший вопрос, @35zvn ! Признаться я сам особо не задумывался, но, подумав, вижу несколько преимуществ подхода с указателями - 1) меньше проверок условий - обе функции используют циклы которые имеют проверку условия окончания. Несмотря на то, что у CPU не должно быть особых проблем предугадать правильную ветку, подход с указателями имеет лишь один цикл 2) немного меньше кода. Это мелкие различия, но раз уж обсуждаются самые производительные решения :)

https://tproger.ru/translations/14-templates-to-answer-interview-questions/
