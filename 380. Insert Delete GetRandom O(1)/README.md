ПЕРЕСМОТРЕТЬ И РЕШИТЬ САМОМУ! НАЙТИ ТЕОРИЮ ПО "Вариант в)" 

https://leetcode.com/problems/insert-delete-getrandom-o1/

https://walkccc.me/LeetCode/problems/0380/

[Разбор задачи 380 leetcode.com Insert Delete GetRandom O(1). Решение на C++](https://www.youtube.com/watch?v=knlHlKV6Uag)

Хотя бы что-то за 0(1) умеют:

insert/remove - хэш-таблица, unordered_set/unordered_тар

Диапазон ключей ничем не ограничен - другие структуры данных со вставкой и удалением 0(1) мне не известны.

Могут быть данные (последовательность), где хэш-таблица даёт O(size) на запрос, где size - текущий размер таблицы.

Когда можно getRandom за O(1) получить?  
Существующий элемент по случайному индексу за O(1) может нам найти - или массив/вектор, или та же хэш-таблица.

Случайные индексы - подряд, логичнее вектор.

В векторе нужно хранить значения, которые вообще сейчас лежат в хэш-таблице.

В хэш-таблице можем ли просто хранить значения?

remove - удалять - нам нужно не только из хэш-таблицы, но из массива со значениями.

| [1] 	| [2] 	| [3] 	| [4] 	| [5] 	| [6] 	| [7] 	|
|-----	|-----	|-----	|-----	|-----	|-----	|-----	|
|     	|     	| ^^^ 	|     	|     	|     	|     	|


Удаляем [3] из массива. Последний элемент ставим на его место, размер сокращаем на 1. 0(1).

| [1] 	| [2] 	| [7] 	| [4] 	| [5] 	| [6] 	| 
|-----	|-----	|-----	|-----	|-----	|-----	|

В хэш-таблице нужно хранить позицию этого числа в массиве.

Поскольку позиция может меняться - может быть нужна и ссылка обратно.

Вариант а)  
unordered_тар<val, index>  
- val - значение из insert/remove  
- index - позиция в векторе vector<val>

Вариант б)  
unordered_тар<val, index>   
vector<unordred_map::iterator>  
- так избегаем ещё одного поиска при изменении позиции элемента

Вариант в)  
хэш-таблица с открытым перемешиванием (?)  
- если не попали в существующий элемент - генерируем случайное число снова.  
- перестраивать таблицу при накоплении некоторого количества удалённых ячеек.


Перевыделение таблицы:  
1. вставка, при этом свободных ячеек стало меньше 2/8  
- или удваиваем, или перевыделяем - в зависимости от числа использованных ячеек. 
Использовано 5/8+ - удваиваем. Меньше - перевыделяем тот же размер.  
2. удаление - и при этом использованных ячеек меньше 2/8  
- сокращаем размер, но не ниже 8.



_____

380b.cpp -- очевидным ускорением является выделением осбого случая при insert/remove  
380с.cpp -- это случай "хэш-таблица с открытым перемешиванием" -- по разбору становится понятно, что такое решение не оптимаально
