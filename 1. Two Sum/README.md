https://leetcode.com/problems/two-sum/

https://walkccc.me/LeetCode/problems/0001/

related: https://github.com/SkosMartren/leetcode_com/tree/main/167.%20Two%20Sum%20II%20-%20Input%20Array%20Is%20Sorted
____________________

В этой задачи входные данные могут быть не отсортированны, в сравнении с 167!

        [7,2,11,15]
        9

        [3,4,5,3,8]
        6

____________________

[Разбор задачи 1 leetcode.com Two Sum. Решение на C++](https://www.youtube.com/watch?v=WEPGndfosls&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)

1. Наивное решение - O(N^2) каждое число с каждым сложить.

2. Сортировка + два указателя O(nlogn) == 167. Two Sum II - Input Array Is Sorted

3. unordered_тар.

а[i] + а[j] = target.

Пусть знаем а[i] -> получаем а[j] = target - а[i]. Можем 
получить второе число пары. Если второе число пары есть в 
массиве - эту пару можно выдавать в качестве ответа.

3.1. Идём по всему массиву, записываем unordered_тар: ключ - 
а[i] - элемент массива, значение - i - индекс, где находится 
значение.

Пройти второй раз и поискать. target - а[i].

Один элемент нельзя использовать дважды. target / 2 два числа.

3.2. Внедряем короткую схему. Можем искать по уже добавленным 
в unordered_тар элементам. Идём по массиву, тут же добавляем -
а тут же ищем target - а[i]. "нельзя использовать дважды" 
диктует порядок: сначала ищеvi, потом добавляем.

O(n) по времени в среднем, O(n) по памяти.


3.3. Переполнения. Не даны ограничения на числа в исходном 
массиве. Python - не проблема.
С++: если результат операции выходит за пределы типа со 
знаком, в котором производится операция - UB.

target = INT_MIN 
а[0] = 1

INT_MIN - 1 уже не можем себе позволить вычислить. 

Вычитать только если можно.

а - b

b > 0 - при вычитании может случиться переполнение только за INT_MIN

а - b >= INT_MIN

а >= INT_MIN + b


b < 0 - при вычитании может случиться переполнение только за INT_МАХ

а - b <= INT_МАХ

а <= INT_МАХ + b

Тест против программ, которые не учитывают переполнение:
[1, INT_МАХ, INT_MIN / 2, INT_MIN / 2] target = INT_MIN

___

Хотя бы одно решение существует, если выполняется уравнение: $target = nums[i] + nums[j] \ : \ i \ != \ j$

Примечательно то, что в обоих решениях используется NumbToIdx -- неупорядоченное отображение числа num [из nums] в последний индекс, где это число 
встречается в nums.

Например: 

nums = {5,7,8,7}

Тогда в конечном итоге NumbToIdx = {{7,3}, {8,2}, {5,0}}

Положим, target = 14 = nums[1] + nums[3]

Также отметим, что в обоих решениях есть проверка вида: 

```objectoves
        const int complement = target - nums[idx];

        if (NumbToIdx.count(complement) && NumbToIdx[complement] != idx) {
            return { NumbToIdx[complement], idx };
        }
```

Здесь 

NumbToIdx.count(complement) -- проврека, что существует [не ограничивая общности] nums[j] для nums[i] 

$NumbToIdx[complement] != idx$ нужно не только для того, чтобы избежать  случай  target = 14 = nums[1] + nums[1], но и использовать nums[j] такой, что он равен nums[i]




