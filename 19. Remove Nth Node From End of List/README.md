https://leetcode.com/problems/remove-nth-node-from-end-of-list/

https://walkccc.me/LeetCode/problems/0019/

____

[Разбор задачи 19 leetcode.com Remove Nth Node From End of List. Решение на C++](https://www.youtube.com/watch?v=-Fak6wi8I98)

19a.cpp  
19b.cpp == https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164542/js-python-java-c-easy-two-pointer-solution-w-explanation/ 

1. Наивный способ. 

Посчитать длину списка. Если длина == n - возвращаем head->next.

Иначе делаем шаги от head в количестве (len - n - 1) - получаем элемент, предшествующий удаляемому. 
Меняем его next на элемент после удаляемого.

cur->next = cur->next->next

Отдельный вопрос - нужно ли удалять недоступный более по списку элемент из кучи, т.е. воспользоваться delete

2. follow up - за один проход.

Операций будет столько же. Два указателя, идущих по списку с расстоянием n / n+1.

___

По условию 1 <= n <= sz --> на nullptr может не указывать --> по отношению к удаляемому элементу всегда можно применить метод next  
Если n = sz, то удалять придется первый элемент head --> ответом будет head = head->next

<p align="center"> Ex 1 </p>

По условию n = 2, тогда: 
  
| head 	|   	| 1 	| 2 	| 3 	|                          4                         	| 5 	| nullptr 	|
|:----:	|:-:	|:-:	|:-:	|:-:	|:--------------------------------------------------:	|:-:	|:-------:	|
|      	|   	|   	|   	|   	| ^^^ <br> n с конца элемент,  <br> его надо удалить 	|   	|         	|

Размер head = 5 == head.size()

<p align="center"> Ex 1 for alg 1. </p>

Заметим, что элемент head под порядковым номером head.size() - n будет указывать на удаляемый элемент.  
Тогда, в результате, элемент под номером head.size() - n - 1 должен указывать на элемент head.size() - n + 1.  
Так как n > 0, то head.size() - n + 1 всегда существует и он не может указвать на nullptr [может указвать только на одно из значений head].  
Существование head.size() - n - 1 можно гарантировать только в том случае, если  head.size() != n. Случай head.size() == n надо отдельно обрабатывать.

<p align="center"> Ex 1 for alg 2. </p>

Сдвинем правый указатель -- r -- на n  

| head 	|   	|      1     	| 2 	|      3     	|         4        	| 5 	| nullptr 	|
|:----:	|:-:	|:----------:	|:-:	|:----------:	|:----------------:	|:-:	|:-------:	|
|      	|   	| ^^^ <br> l 	|   	| ^^^ <br> r 	| ^^^ <br> r->next 	|   	|         	|

После чего сдвигаем указатели l и r до тех пор, пока r->next == nullptr, тогда l->next будет указывать на элемент, который надо удалить.

| head 	|   	| 1 	|      2     	| 3 	|      4     	|         5        	| nullptr 	|
|:----:	|:-:	|:-:	|:----------:	|:-:	|:----------:	|:----------------:	|:-------:	|
|      	|   	|   	| ^^^ <br> l 	|   	| ^^^ <br> r 	| ^^^ <br> r->next 	|         	|

| head 	|   	| 1 	| 2 	|      3     	| 4 	|      5     	|      nullptr     	|
|:----:	|:-:	|:-:	|:-:	|:----------:	|:-:	|:----------:	|:----------------:	|
|      	|   	|   	|   	| ^^^ <br> l 	|   	| ^^^ <br> r 	| ^^^ <br> r->next 	|

Стоит отметить, что это решение должно гарантировать существование l [элемента, предществующего удаляемому]. Крайний случай, когда такое невозможно -- это head.size() = n. Поэтому 
случай head.size() == n надо отдельно обрабатывать.

<p align="center"> My Ex 1 for alg 1. </p>
Wrong Answer 190 / 208 testcases passed

head = [1,2]  
n = 2

Expected [2]
