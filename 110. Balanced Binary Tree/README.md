https://leetcode.com/problems/balanced-binary-tree/

https://walkccc.me/LeetCode/problems/0110/

110a.cpp -- алгоритм 3.  
110b.cpp -- алгоритм 1.
_______________________

[Разбор задачи 110 leetcode.com Balanced Binary Tree. Решение на C++](https://www.youtube.com/watch?v=96p-hKzC6Qo)

1. Наивный алгоритм

обходим дерево, из каждой ноды вызываем получение высот левого и правого поддеревьев.

Если дерево вырожденное в список - O(n^2) по времени, O(height) по памяти.

1
|
2
|
3
|
4


  2 
 / \ 
1   3


2. Кэширование высот поддеревьев.

O(n) по времени, O(n) по памяти - придётся хранить высоту каждой вершины. 

unordered_mар<TreeNode*, int> heights;

З. Оптимальный. 

Вычисляем высоту каждого поддерева один раз - и тут же используем, нигде не храним. 

Создадим функцию, которая и находит высоту, и проверяет сбалансированность.

Например, возвращает 0+ если всё в порядке со сбалансированностью, и это высота поддерева. 
Возвращает -1, если дерево несбалансированное.

Вызываем для left, вызываем для right. Если какое-то из них -1, возвращаем -1. 
Если оба неотрицательные - находим разницу, если разница > 1 - ответ -1.

O(n) по времени O(height) по памяти.

3.1. Короткая схема. Если в левом поддереве есть дисбаланс - для правого не вызываем функцию. 
Те же оценки по времени и памяти, но позволяет иногда делать меньше действий, и при этом не увеличивает существенно расходы в общем случае.

_______________________
