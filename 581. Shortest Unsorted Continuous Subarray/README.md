РЕШИТЬ ДЛЯ НАЧАЛА ЗА O(N) ПО ПАМЯТИ!

https://leetcode.com/problems/shortest-unsorted-continuous-subarray/description/

https://walkccc.me/LeetCode/problems/0581/

____

[Разбор задачи 581 leetcode.com Shortest Unsorted Continuous Subarray. Решение на C++](https://www.youtube.com/watch?v=WSLTFJ_aiB8)

17:50 -- начало кода

0. Совсем плохо: перебираем границы, что можно отсортировать - и явно сортируем. Смотрим, стало ли отсортировано.

N^2 - вариантов левой и правой границы, NlogN сортировка. 

O(N^3 * logN)

N=100 - ~8 млн операций
N=1000 - ~10 млрд операций - несколько секунд

3а 1 секунду можно 10^8-10^9

1. Получше: из каждого числа создаём пару (число, индекс в 
исходном массиве), сортируем эти пары устойчивой сортировкой 
по возрастанию (неубыванию) чисел. Какие индексы остались на 
месте - такие последовательности начальных и конечных чисел 
можно оставить.

2(0), б(1), 4(2), 8(3), 10(4), 9(5), 15(6)


2(0), 4(2), б(1), 8(3), 9(5), 10(4), 15(6) 

О(NlogN) за счёт сортировки. Это должно проходить. 

N- 1 млн - сортировка в 1 с уложится.

2. Оптимальный: O(n) по времени  | O(1) по памяти

Можно ли выяснить отсортированность концов без выполнения 
сортировки в явном виде?

 2 6 4 8 10 9 15

Для каждого числа: оно в правильном месте в отсортированной последовательности, если: 

а) оно максимальное из тех, которые идут раньше него,  
б) оно минимальное из тех, которые идут после него.  
ИЛИ ЭКВИВАЛЕНТ  
до него не встречается больших, после него не встречается меньших.  
ИЛИ ЭКВИВАЛЕНТ  
Если *условие отсортированности* **не нарушено**, то:
- sort(nums) = vector <int> MAX при заполнении слева направа (отсортированная последовательность слева направа возраастает) посредством MAX[i] = max(MAX[i - 1], nums[i]) 
- sort(nums) = vector <int> MIN при заполнении справа налева (отсортированная последовательность справа налева убывает) посредством MIN[i] = min(MIN[i + 1], nums[i])

3а один проход проставить у всех чисел признаки, правда ли, что это число >= чем все числа левее.

| 2 	| 6 	| 4 	| 8 	| 10 	|  9 	| 15 	|   	|                  nums                  	|
|:-:	|:-:	|:-:	|:-:	|:--:	|:--:	|:--:	|:-:	|:--------------------------------------:	|
| 2 	| 6 	| 6 	| 8 	| 10 	| 10 	| 15 	|   	|  max из всех чисел левее включительно  	|
| 2 	| 4 	| 4 	| 8 	|  9 	|  9 	| 15 	|   	| min из всех чисел правее включительно 	 |
| 2 	| 4 	| 6 	| 8 	| 9  	|  10 | 15 	|   	|                  sort                  	|

- "MAX" == "max из всех чисел левее включительно" заполняется слева направа
- "MIN" == "min из всех чисел правее включительно" заполняется справа налева
- В "MAX" ищем первое нарушение условия $nums[i] ==  MAX[i]$ идя справа налева
- В "MIN" ищем первое нарушение условия $nums[i] == MIN[i]$ идя слева направа

Идём от границ, пока числа на месте - продолжаем двигаться. 
Как только число не на месте - это граница отрезка, который нужно отсортировать.

O(n) по времени   
O(n) по памяти  

? O(1) по памяти ?

Когда идём справа налево - последнее число, которое больше min из всех правее - видимо эта граница.

Когда идём слева направо и считаем максимум - последнее число, 
которое меньше тах из всех левее - видимо эта граница.

O(1) по памяти.

____

@cuul55
3 года назад  
Спасибо за объяснение. А есть ли возможность написать проход в один цикл, начиная с двух сторон одновременно?


@35zvn
3 года назад  
Конечно. Цикл for (int i = 0; i < n; i++) обращение с одной стороны к a[i], с другой к a[n - 1 - i]

____

Если сортировка нарушена, значит есть два крайних элемента 

НЕ ФАКТ ЧТО ВЕРНО НИЖЕНАПИСАННОЕ, СЧИТАТЬ БРАКОМ ВПЛОТЬ ДО РЕДАКТИРОВАНИЯ!

Перефраз условия задачи: надо найти такой минимальный интервал, что если его отсортировать в порядке возростания, то весь массив будет отсортирован

Рассмотрим отсортированную последовательность $N = {n_1, n_2, ..., n_k}$ <--> $n_1 \leqslant n_2 \leqslant ... \leqslant n_k$. Заметим *условие отсортированности:* для цепочки неравенств выполняется условие   
- до $n_t$ числа не превосходят $n_t$, 
- после $n_t$ числа не меньше $n_t$.  

Выполним в цепочке неравенств перестановку $p$ чисел, обозначим новую последовательность как N'. Тогда, если *условие отсортированности* для некоторого числа выполнено, то его можно не пересталвять при попытке отсортировать N'. Теперь услвоие задачи можно записать так: найти крайние [слева и справа] элементы, для которых *условие отсортированности* нарушено. 
Положим, это произойдет по индексам (Leftptr, RightPtr) --> его размер равен RightPtr - Leftptr + 1 
