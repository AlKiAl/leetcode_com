https://leetcode.com/problems/shortest-unsorted-continuous-subarray/description/

https://walkccc.me/LeetCode/problems/0581/

____

[Разбор задачи 581 leetcode.com Shortest Unsorted Continuous Subarray. Решение на C++](https://www.youtube.com/watch?v=WSLTFJ_aiB8)

17:50 -- начало кода

0. Совсем плохо: перебираем границы, что можно отсортировать - и явно сортируем. Смотрим, стало ли отсортировано.

N^2 - вариантов левой и правой границы, NlogN сортировка. 

O(N^3 * logN)

N=100 - ~8 млн операций
N=1000 - ~10 млрд операций - несколько секунд

3а 1 секунду можно 10^8-10^9

1. Получше: из каждого числа создаём пару (число, индекс в 
исходном массиве), сортируем эти пары устойчивой сортировкой 
по возрастанию (неубыванию) чисел. Какие индексы остались на 
месте - такие последовательности начальных и конечных чисел 
можно оставить.

2(0), б(1), 4(2), 8(3), 10(4), 9(5), 15(6)


2(0), 4(2), б(1), 8(3), 9(5), 10(4), 15(6) 

О(NlogN) за счёт сортировки. Это должно проходить. 

N- 1 млн - сортировка в 1 с уложится.

2. Оптимальный: O(n) по времени  | O(1) по памяти

Можно ли выяснить отсортированность концов без выполнения 
сортировки в явном виде?

 2 б 4 8 10 9 15

Для каждого числа: оно в правильном месте в отсортированной 
последовательности, если 

а) оно максимальное из тех, которые идут раньше него,  
б) оно минимальное из тех, которые идут после него.  
ИЛИ  
до него не встречается больших, после него не встречается меньших.

3а один проход проставить у всех чисел признаки, правда ли, что это число >= чем все числа левее.

| 2 	| 6 	| 4 	| 8 	| 10 	|  9 	| 15 	|   	|                  nums                  	|
|:-:	|:-:	|:-:	|:-:	|:--:	|:--:	|:--:	|:-:	|:--------------------------------------:	|
| 2 	| 6 	| 6 	| 8 	| 10 	| 10 	| 15 	|   	|  max из всех чисел левее включительно  	|
| 2 	| 4 	| 4 	| 8 	|  9 	|  9 	| 15 	|   	| min из всех чисел правее, включительно 	|

Идём от границ, пока числа на месте - продолжаем двигаться. 
Как только число не на месте - это граница отрезка, который нужно отсортировать.

O(n) по времени   
O(n) по памяти  

? O(1) по памяти ?

Когда идём справа налево - последнее число, которое больше min из всех правее - видимо эта граница.

Когда идём слева направо и считаем максимум - последнее число, 
которое меньше тах из всех левее - видимо эта граница.

O(1) по памяти.

