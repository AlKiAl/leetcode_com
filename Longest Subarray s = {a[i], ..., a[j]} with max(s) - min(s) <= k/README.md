https://t.me/algoses/129

Задача Яндекса. 

Дается массив a из целых положительных чисел, а также число k. Найти максимальный по длине подотрезок в котором разница между максимальным и минимальным элементом будет не больше k. 

Решение: 
Наум, конечно, приходит два указателя. Это, кстати, хорошая идея.

И так, думаем в сторону двух указателей. Всё по шаблону, перебираем правый край отрезка 0 <= r < n, для каждого такого r будем искать оптимальный l, в котором разница максимального и минимального элемента не больше k. 
Можно легко понять, что для каждого следующего r его оптимальный l будет не левее чем  l для r - 1. 

Осталось только быстро находить минимум и максимум на отрезке... Да, конечно, можно попытаться написать дерево отрезков, что позволит вам находить мин/макс за логарифм, но, к сожалению, задачу так не засчитают, нужно научиться за константу находить. 

Для тех, кто не знал, можно с помощью монотонного стека находить мин/макс на отрезке, а в этой задаче нам понадобятся два монотонных стека, один для минимума, другой для максимума. [Вот пример ](https://www.geeksforgeeks.org/find-the-maximum-of-minimums-for-every-window-size-in-a-given-array/). 

И так для решения - этой задачи нужно было хранить два стека. (ГПТ кстати хорошо решает такую задачу :)) 

Время работы алгоритма O(N)

---

Да, в решении используется структура данных, схожая с **монотонным стеком**, а именно **монотонная дека**. Разберём, как это связано.

### Что такое монотонный стек?
Монотонный стек — это структура данных, которая поддерживает элементы в порядке возрастания или убывания. Основная идея — удалять элементы, которые становятся неактуальными, чтобы минимизировать количество операций и эффективно обрабатывать диапазоны.

В данном решении для **максимального** и **минимального** элементов в текущем подотрезке применяются две **монотонные деки**:

1. **`minDeque`** — поддерживает минимальный элемент текущего окна, упорядоченный в неубывающем порядке.
2. **`maxDeque`** — поддерживает максимальный элемент текущего окна, упорядоченный в невозрастающем порядке.

### Где используется монотонность?
Монотонность обеспечивается в следующих частях кода:

#### 1. Обновление `minDeque` для минимального элемента:
```cpp
while (!minDeque.empty() && nums[right] <= nums[minDeque.back()]) {
    minDeque.pop_back();
}
minDeque.push_back(right);
```
- **Монотонность:** Дека `minDeque` хранит индексы элементов массива `nums` в порядке **неубывания** значений.
- **Почему удаляем элементы из конца:** Если текущий элемент `nums[right]` меньше или равен элементу, находящемуся в конце дека, то последний элемент в деке становится неактуальным, так как `nums[right]` будет минимальным на этом подотрезке.

#### 2. Обновление `maxDeque` для максимального элемента:
```cpp
while (!maxDeque.empty() && nums[right] >= nums[maxDeque.back()]) {
    maxDeque.pop_back();
}
maxDeque.push_back(right);
```
- **Монотонность:** Дека `maxDeque` хранит индексы элементов массива `nums` в порядке **невозрастания** значений.
- **Почему удаляем элементы из конца:** Если текущий элемент `nums[right]` больше или равен элементу, находящемуся в конце дека, то последний элемент становится неактуальным, так как `nums[right]` будет максимальным на этом подотрезке.

#### 3. Удаление устаревших элементов:
```cpp
if (minDeque.front() < left) {
    minDeque.pop_front();
}
if (maxDeque.front() < left) {
    maxDeque.pop_front();
}
```
- Элементы, которые выходят за пределы текущего окна (индекс меньше `left`), удаляются из дека.

### Итог:
- **Монотонный стек используется дважды в виде монотонных дек:**
  - `minDeque` для минимальных значений.
  - `maxDeque` для максимальных значений.
- Монотонность этих дек обеспечивает быстрый доступ к минимальному и максимальному элементам в окне.

Эта реализация полностью опирается на свойства монотонных стеков (дек), чтобы добиться временной сложности \( O(n) \).
