ПРЕДОСТАВИТЬ СЕРТИФИКАТ! МОЖНО КАК-ТО РЕШИТЬ ЧЕРЕЗ ПРЕФИКСНЫЕ СУММЫ?

https://leetcode.com/problems/maximum-subarray/

https://walkccc.me/LeetCode/problems/0053/

https://www.techiedelight.com/ru/maximum-subarray-problem-kadanes-algorithm/

https://www.youtube.com/watch?v=MCriLqc_8sY&t=52s == два указателя?

https://leetcode.com/problems/maximum-subarray/solutions/ -- см. топ 3

____

[Разбор задачи 53 leetcode.com Maximum Subarray. Решение на C++](https://www.youtube.com/watch?v=JGoQK5MUbIY) -- остановился на 13 минуте

1. Наивное решение: 

перебираем все подмассивы [i,j] - находим в них суммы, выбираем лучшую. O(N^3) по времени, O(1) по дополнительной памяти.

2. Улучшенное решение: 

перебираем все начала подмассива [i - и 
идём от этого начала до конца, добавляя в сумму.  
Новую сумму считаем из предыдущей за O(1).  
Итого O(N^2) по времени, O(1) по дополнительной памяти.

3. Динамическое программирование - алгоритм Кадана.

[kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem)

Для каждой позиции получаем максимальную сумму, которую можно получить, если эта позиция - последняя позиция интервала.

Если позиция первая в массиве - ответ для этой позиции совпадает с элементом массива.

Если позиция не первая - тогда можно выбрать - или взять интервал из одной этой позиции, или взять эту позицию - и лучший интервал для позиции перед ней.  
Выбираем из этих двух значений максимум.

Для каждой позиции находим максимум сумм, которые можно получить, если отрезок массива заканчивается в этой позиции.  
Ответ - максимум по всем таким позициям.  
O(n) по времени O(1) по дополнительной памяти.


4. Разделяй и властвуй.

Делим массив на две части, вычисляем некую статистику для обеих частей, после чего объединяем эту статистику - и получаем статистику для всего массива.  
Для частей аналогично рекурсивно - пока там не останется 1 элемент.

Лучший подмассив: или в одной части, или в другой, или проходит через границу.  
Если в одной или в другой полностью - это исходная задача, для любого подмассива нам нужно решить исходную задачу - максимальная сумма в подмассиве.

Проходит через границу: для первой части нам нужно найти максимальную сумму, которую можно получить на суффиксе этой части, для второй части нужно найти максимальную сумму на префиксе этой части.  
Префиксы и суффиксы непустые, иначе искомый отрезок полностью лежит в анализируемом.

Для каждого отрезка получить:  
а) лучшую сумму непрерывного отрезка - исходная задача,  
б) лучшую сумму непустого префикса  
в) лучшую сумму непустого суффикса  
г) сумма всего интервала.  

_______

Что такое size_t? И чем он лучше int?

Лучше он в том, что его гарантированно хватает для индексации массива/вектора, помещающегося в память. На 64-битных системах int бывает до 2 млрд с небольшим, а массивы можно создавать более чем на 2 млрд элементов.
