https://leetcode.com/problems/maximum-subarray/

https://walkccc.me/LeetCode/problems/0053/

https://www.techiedelight.com/ru/maximum-subarray-problem-kadanes-algorithm/

https://www.youtube.com/watch?v=MCriLqc_8sY&t=52s == два указателя?

https://leetcode.com/problems/maximum-subarray/solutions/ -- см. топ 3


Предположим, что nums[i] -- последний элемент, так как его либо надо брать в текущие окно, либо начинать с него новое окно, либо не брать (иных вариантов нет) тогда возможно:
1. Он является искомым, берем, например: [-1,-2,42]
2. Его стоит добавить к иному оптимальному окну, берем, например:  [-1,2,42],  [1,2,42]
3. его не стоит брать, так как он уменьшает сумму окна, например:  [-1,2,-42], [1,2,-42]
4. начинаем с него новое окно, например: [1,-2,42, 11, -18]

        CurrentMaxAffixSum = max(CurrentMaxAffixSum + nums[i], nums[i]); // обработка 1. , 2. , 4.
        TotalMaxAffixSum = max(TotalMaxAffixSum, CurrentMaxAffixSum); // обработка 3.

____

my_code_general.cpp <-- my_code_ptr_subarray.cpp

[Разбор задачи 53 leetcode.com Maximum Subarray. Решение на C++](https://www.youtube.com/watch?v=JGoQK5MUbIY)

53a.cpp - алгоритм Кадана  
53b.cpp - Разделяй и властвуй: медленное и более затратное.

1. Наивное решение: 

перебираем все подмассивы [i,j] - находим в них суммы, выбираем лучшую. O(N^3) по времени, O(1) по дополнительной памяти.

2. Улучшенное решение: 

перебираем все начала подмассива [i - и 
идём от этого начала до конца, добавляя в сумму.  
Новую сумму считаем из предыдущей за O(1).  

Итого  
O(N^2) по времени  
O(1) по дополнительной памяти.

3. Динамическое программирование - алгоритм Кадана.

[kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem)

Для каждой позиции получаем максимальную сумму, которую можно получить, если эта позиция - последняя позиция интервала.

Если позиция первая в массиве - ответ для этой позиции совпадает с элементом массива.

Если позиция не первая - тогда можно выбрать - или взять интервал из одной этой позиции, или взять эту позицию - и лучший интервал для позиции перед ней.  
Выбираем из этих двух значений максимум.

Для каждой позиции находим максимум сумм, которые можно получить, если отрезок массива заканчивается в этой позиции.  
Ответ - максимум по всем таким позициям.  

O(n) по времени  
O(1) по дополнительной памяти.


4. Разделяй и властвуй.

Делим массив на две части, вычисляем некую статистику для обеих частей, после чего объединяем эту статистику - и получаем статистику для всего массива.  
Для частей аналогично рекурсивно - пока там не останется 1 элемент.

Лучший подмассив: или в одной части, или в другой, или проходит через границу.  
Если в одной или в другой полностью - это исходная задача, для любого подмассива нам нужно решить исходную задачу - максимальная сумма в подмассиве.

Проходит через границу: для первой части нам нужно найти максимальную сумму, которую можно получить на суффиксе этой части, для второй части нужно найти максимальную сумму на префиксе этой части.  
Префиксы и суффиксы непустые, иначе искомый отрезок полностью лежит в анализируемом.

Для каждого отрезка получить:  
а) лучшую сумму непрерывного отрезка - исходная задача,  
б) лучшую сумму непустого префикса  
в) лучшую сумму непустого суффикса  
г) сумма всего интервала.  

O(n) по времени - ~ геометрическая прогрессия 1 2 4 8  
О(logn) по памяти - стек.



https://habr.com/ru/articles/539166/

$O(n)$. Завести новый массив T[1..n], где i-тый элемент равен наибольшей сумме подмассива, оканчивающегося в i. Оказывается, можно считать $T$ за линию, а конечным ответом будет наибольшее из $T$. Это так называемый алгоритм Кадана

Нам интересен последний вариант. Давайте подумаем, как найти T[i + 1], зная T[i]? Если мы знаем сумму наибольшего подмассива, оканчивающегося в i, то следующий элемент может либо расширять его, либо начать новый подмассив. Действительно, T[i + 1] может быть либо T[i] + A[i + 1], либо A[i + 1], либо 0, если A[i + 1] < 0. Получаем реккурентную формулу:


T[0] = 0,
T[i + 1] = max{T[i] + A[i + 1], A[i + 1], 0} = max{T[i] + A[i + 1], 0}

Докажем последнее равенство. Понятно, что T[i] >= 0 для любого i. Пусть k = A[i + 1]. Рассмотрим три случая:


k < 0. Тогда 0 превзойдёт k в первом max.
k = 0. В первом max можно просто убрать второй аргумент.
k > 0. Тогда max{T[i] + k, k, 0} = T[i] + k = max{T[i] + k, 0}.
_______

Что такое size_t? И чем он лучше int?

Лучше он в том, что его гарантированно хватает для индексации массива/вектора, помещающегося в память. На 64-битных системах int бывает до 2 млрд с небольшим, а массивы можно создавать более чем на 2 млрд элементов.

___

| Step | nums                            | tempStart | Start | End | curSumAf        | minSumAf    | maxSum | currentSumAffix - minSumAffix |
|------|---------------------------------|-----------|-------|-----|-----------------|-------------|--------|-------------------------------|
| 0    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 0         | 0     | 0   | 0               | 0           | -2     | -2                            |
| 1    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 0         | 0     | 0   | -2              | -2          | -2     | 0                             |
| 2    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 1         | 1     | 1   | -1              | -2          | 1      | 1                             |
| 3    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 1         | 1     | 1   | -4              | -4          | 1      | 0                             |
| 4    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 4         | 3     | 3   | 0               | -4          | 4      | 4                             |
| 5    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 4         | 3     | 3   | -1              | -4          | 4      | 3                             |
| 6    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 4         | 3     | 5   | 1               | -4          | 6      | 5                             |
| 7    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 4         | 3     | 6   | 2               | -4          | 7      | 6                             |
| 8    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 4         | 3     | 6   | -3              | -4          | 7      | 1                             |
| 9    | [-2, 1, -3, 4, -1, 2, 1, -5, 4] | 4         | 3     | 6   | 1               | -4          | 7      | 5                             |

