class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        
        int maxSum = nums.front();
        int currentSum = 0;
        
        for(int i = 0; i < nums.size(); ++i){

            currentSum += nums[i];

            if(maxSum < currentSum){
                maxSum = currentSum;
            }

            if(currentSum <= 0){
                currentSum = 0;
            }
        }

        return maxSum;
    }
};

/*
Этот алгоритм решает задачу нахождения подмассива с максимальной суммой в массиве целых чисел. Он использует известный алгоритм Кадане, который работает за линейное время 
𝑂
(
𝑛
)
O(n). Давайте разберем его по шагам:

Алгоритм Кадане
Инициализация
int maxSum = INT_MIN;:
maxSum инициализируется минимальным возможным значением целого числа. Это необходимо, чтобы гарантировать, что любое значение из массива станет новым максимумом при первой итерации.
int currentSum = 0;:
currentSum инициализируется нулем. Эта переменная будет использоваться для хранения суммы текущего подмассива.
Итерация по массиву
for(int i = 0; i < nums.size(); ++i):

Цикл проходит через каждый элемент массива nums.
currentSum += nums[i];:

Текущий элемент добавляется к currentSum. Это расширяет текущий подмассив, включив в него nums[i].
if(maxSum < currentSum):

Если сумма текущего подмассива (currentSum) больше, чем максимальная найденная до сих пор (maxSum), обновляем maxSum.
maxSum = currentSum;:

Обновляем maxSum текущей суммой, так как она больше предыдущей.
if(currentSum < 0):

Если currentSum становится отрицательной, это означает, что включение текущего подмассива в будущие подмассивы не имеет смысла, потому что оно будет только уменьшать сумму.
currentSum = 0;:

Обнуляем currentSum, чтобы начать накопление суммы для нового подмассива.
Завершение
return maxSum;:
Возвращаем максимальную сумму подмассива, найденную в процессе итерации.
Пример
Рассмотрим пример массива nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] и пройдем через алгоритм шаг за шагом:

Инициализация:

maxSum = INT_MIN
currentSum = 0
Итерации:

i = 0: currentSum = -2, maxSum = -2
i = 1: currentSum = -1, maxSum = -1
i = 2: currentSum = -4, currentSum = 0 (обнуление)
i = 3: currentSum = 4, maxSum = 4
i = 4: currentSum = 3, maxSum = 4
i = 5: currentSum = 5, maxSum = 5
i = 6: currentSum = 6, maxSum = 6
i = 7: currentSum = 1, maxSum = 6
i = 8: currentSum = 5, maxSum = 6
Возвращаем maxSum = 6.

Алгоритм эффективно находит максимальную сумму подмассива, используя линейное время и константную память.
*/
