https://leetcode.com/problems/merge-intervals/description/

related 
- https://github.com/SkosMartren/leetcode_com/tree/main/986.%20Interval%20List%20Intersections -- обратная задача: надо найти пересечение, а в исходной -- объединение    
- https://github.com/SkosMartren/leetcode_com/tree/main/763.%20Partition%20Labels -- аналог

https://github.com/doocs/leetcode/tree/main/solution/0000-0099/0056.Merge%20Intervals

https://walkccc.me/LeetCode/problems/0056/

__________

[Разбор задачи 56 leetcode.com Merge Intervals. Решение на C++](https://www.youtube.com/watch?v=PIUaSD1c0AY)

0. Наивный подход. Берём каждый исходный отрезок - и ищем, с какими он имеет пересечения. Потенциально 0(n^2). 

Худший случай - нет пересечений, нужно каждый с каждым сравнить, чтобы понять, что это действительно так.

1. Группировка интервалов по тому, какие могут быть объединены.

Сортируем по левой границе интервала.

Если интервал не слился со следующим (а у него минимальное значение левой границы) - то со следующими после 
него интервал точно не сольётся.

Если слился - можем рассматривать объединённый интервал - и сливать со следующими. 

правая граница слитого - тах из правых границ исходных слитых интервалов.

После сортировки O(n) - один проход по интервалам.

Сортировка занимает O(nlogn) по времени, в std::sort O(logn) по памяти.

____

Замечание:   

При формировании тестов надо рассмотреть три случия: 

1. Вложенность  
2. Пересечение слева  
3. Пересечение справа  
