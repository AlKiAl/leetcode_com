https://leetcode.com/problems/top-k-frequent-elements/

https://walkccc.me/LeetCode/problems/0347/

analoge: https://github.com/SkosMartren/leetcode_com/tree/main/692.%20Top%20K%20Frequent%20Words
__________

[Разбор задачи 347 leetcode.com Top K Frequent Elements. Решение на C++](https://www.youtube.com/watch?v=gamjygyIzg0)

0. Считаем частоту элементов. -- делается всегда, далее пункт 1. и 2. на выбор

unordered_map<int-key, int-count>

3а один проход по исходному массиву O(n) получаем таблицу частот. Как часто какой элемент встречается.

1. Выделяем пары из таблицы в массив, делаем nth_element. 
Разделяем элементы по границе k. 
Которые до границы - с таким же количеством или чаще, после границы - с таким же количеством или реже.

O(n) по времени и по памяти.

2. Много разных count - количеств элементов - быть не может.

1 2 3 4 5 6... -- элементы count

Х частот от 1 до Х - количество элементов исходного массива

(1+Х)*Х/2. Или примерно Х^2/2. Если n - размер исходного массива, то количество частот ~ sgrt(2n) - максимум.

O(sqrt(n)) - количество частот.  
unordered_map<int-count, vector<int>-keys>  
Теперь ключи сгруппированы по частотам за O(n)

Можем отсортировать частоты - ключи этого unordered_map.

ключей ~ sqrt(n) сортировка nlog(n) - здесь в качестве n будет n^0.5

O(n^0.5 * log(n^0.5)) = O(sgrt(n) * log(n)) < O(n)

Отсортируем частоты - и сделаем обход этих частот по убыванию, для каждой частоты обходим ключи из второго unordered_map. 
Как только набралось К - завершаем работу.
