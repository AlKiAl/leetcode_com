<p align="center"> Пример 0 </p>

|   	|     1    	| 2 	| 3 	| 4        	| 5  	| а[i]                         	|
|:-:	|:--------:	|---	|---	|----------	|----	|------------------------------	|
| 0 	|     1    	| 3 	| 6 	| 10       	| 15 	| sum(а[0]..а[i])              	|
| 0 	|     1    	| 3 	| 6 	| 0        	| 5  	| sum(а[0]..а[i]) % k, k == 10 	|
|  ^ <br> l 	|  	|   	|   	| ^ <br> r 	|    	|                              	|

<p align="center"> 86 / 98 testcases  </p>

|   	| 0 	| а[i]                        	|
|:-:	|:-:	|-----------------------------	|
| 0 	| 0 	| sum(а[0]..а[i])             	|
| 0 	| 0 	| sum(а[0]..а[i]) % k, k == 1 	|

Expected: false

_____________________

[Разбор задачи 523 leetcode.com Continuous Subarray Sum. Решение на C++](https://www.youtube.com/watch?v=q7tOK0JsHWo&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)

1. Наивный алгоритм.

Перебираем позицию начала подмассива, позицию конца подмассива, идём по подмассиву, суммируем. 
3а одну операцию (% k) проверяем, что сумма кратна k. k == 0 - отдельное условие, что сумма подмассива О. 
Подмассив длины хотя бы 2 - позиции конца перебираем от позиции начала +1.

n - длина массива

0(n^3) по времени  -- n раз перебираем начало -- l, n раз перебираем конец -- r, перебираем [l, r] -- в худшем случае n раз  
0(1) по памяти

10.000^3 = 10^12.
3а 1 секунду успеваем 10^8.

Гарантирован ответ Time limit ехсеедед.

2. Ускоряем до 0(n^2)

будем находить сумму одновременно с движением позиции конца 
подмассива.

<!--
   2 3 5 7
   ^
   flrst
       ^
      lаst
-->

|     2    	|     3    	| 5 	| 7 	| nums 	|
|:--------:	|:--------:	|---	|---	|------	|
| ^ <br> f 	| ^ <br> l 	|   	|   	|      	|

|     2    	|     3    	| 5 	| 7 	| nums 	|
|:--------:	|:--------:	|---	|---	|------	|
| ^ <br> f 	| 	|  ^ <br> l 	|    	|      	|

Двинули lаst - к сумме предыдущего отрезка добавилось только последнее число.

0(n^2) по времени  
0(1) по памяти

10.000^2 = 10^8.  
3а 1 секунду успеваем 10^8. На границе может проходить.  
На lееtсоdе обычно десятки тестов, и сколько их них максимальные - задача на задачу не приходится.

3. Альтенативно ускоряем до 0(n^2)

Можем за 0(1) посчитать сумму любого непрерывного отрезка, если 
заранее подготовим массив интегральных сумм - то есть сумм от 0-го 
элемента до i-го.

 sum[L,R] = sum[R] - sum[L-1]

<!--
 23 5 7  
0 2 5 10 17  
  [ ]
-->

|   	| 2 	| 3        	| 5        	| 7  	| nums      	|
|:-:	|:-:	|----------	|----------	|----	|-----------	|
| 0 	| 2 	| 5        	| 10       	| 17 	| PrefixSum 	|
|   	|   	| ^ <br> l 	| ^ <br> r 	|    	|           	|

0(n^2) по времени  
0(n) по памяти  

4. Ускоряеам еще

Что если бы сумма должна быть ровно k? (а не кратна k)

Могли бы запоминать, какие суммы уже были - и по новой сумме, 
вычитая k, получали бы значение, которое должно было бы встречаться ранее.

k = sum[R] - sum[L-1] <--> sum[L-1] = sum[R] - k 

Что-то сделать с множителем у k.

Когда говорится о кратности - полезно работать с остатками от 
деления.

Кратно 4 - будем работать с остатками от деления на 4.

будем считать интегральные суммы по модулю k. (k == 0 отдельный 
случай)

<!--
   2 3  5  7  а[i]
 0 2 5 10 17  sum(а[0]..а[i]) 
 0 2 1  2  1  sum(а[0]..а[i]) % k,  k == 4
    [    ]
-->

|   	| 2 	| 3        	| 5        	| 7  	| а[i]                        	|
|:-:	|:-:	|----------	|----------	|----	|-----------------------------	|
| 0 	| 2 	| 5        	| 10       	| 17 	| sum(а[0]..а[i])             	|
| 0 	| 2 	| 1        	| 2        	| 1  	| sum(а[0]..а[i]) % k, k == 4 	|
|   	|   	| ^ <br> l 	| ^ <br> r 	|    	|                             	|

Кратно k: sum[R] - sum[L-1] == 0 (mod k)  <--> sum[R] == sum[L-1]

Нам нужно найти две одинаковые интегральные суммы. 
длина хотя бы 2 - не соседние.

Можем отмечать в unordered_set или unordered_тар, какие суммы по 
(модулю k уже были. Если появляется новая такая же - возвращаем True

Что делать с длиной хотя бы 2:
а) отставать на 1 ход при занесении суммы - unordered_set  
б) запоминать в unordered_тар размер первого префикса, где 
встретилась такая сумма [sum] -> firstPos. С таким подходом 2 не 
особый случай - можем себе позволить 5 или 10.  

0(n) в среднем по времени - из-за использования хэш-таблицы  
0(n) по памяти  

Если хочется гарантий:  
О(nlogn) по времени - set/map/sort  
0(n) по памяти  

Что делать с k == 0. Нельзя брать префиксы %k. Можем считать суммы на префиксах. Если встретился ровно такой префикс - ответ да.  
Для k == 0 можно и без хэш-таблиц - достаточно найти два 0 подряд. 

k < 0 изменений кода не требуется: 5 % (-3) == -2




__________________________

To understand this question, you have to understand how remainders work. If k = 5, then 6 % 5 = 1, which also means (6 + 5) % 5 = 1.  
So you use a hash map to check if you have seen that remainder before. If yes, then you know between both indexes, it is 5 (i.e. (6 + 5) - 6 = 5).  
This question tests nothing other than knowing how remainders work.

This helped me visualize the ans. In the example:
[23,2,6,4,7] k =12

(23)%12 = 11  
(23+2)%12=1  
(23+2+6)%12 = 7  
(23+2+6+4)%12=11 -> seen before, so return true because:

(23+2+6+4) - (23) = 12 -> 12 % 12 = 0
