https://leetcode.com/problems/min-stack/

https://walkccc.me/LeetCode/problems/0155/

________

[Разбор задачи 155 leetcode.com Min Stack. Решение на C++](https://www.youtube.com/watch?v=NNCWMFT1e24)

0(1) по времени на каждую операцию.

0. Наивное решение - держать элементы стека например в std::vector - push 
- push_back, рор() - рор_back(), tор() - back(), getMin - идём по всем
элементам и находим минимум.

push - amortized O(1), рор - O(1), top() - O(1), getMin - O(n), n - число 
элементов в текущем стеке.

0b. - хранить множество (std::set) из текущих элементов - находим минимум за О(log(n)), n - текущее число элементов в стеке.

1. Общий подход: 

держать 2 стека. В одном собственно элементы, во втором - минимумы на текущий момент.

Когда добавляем элемент - знаем минимум от всех элементов, кроме нового - 
и по старому минимуму и новому элементу - можем найти значение нового 
минимума. O(1) находится

Когда убираем - убираем и из стеке минимумов последний элемент - возвращаемся к стеку минимумов для меньшего размера стека.

Получение минимума - верхний элемент второго стека.

values[]  
mins[]

push(-2)

values[-2]  
mins[-2]

push(0)

values[-2,0]  
mins[-2,-2]

push(-3)

values[-2,0,-3]  
mins[-2,-2,-3]

getMin -> -3

pop()

values[-2,0]  
mins[-2,-2]

