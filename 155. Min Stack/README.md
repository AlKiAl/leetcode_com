https://leetcode.com/problems/min-stack/

https://walkccc.me/LeetCode/problems/0155/

________

[Разбор задачи 155 leetcode.com Min Stack. Решение на C++](https://www.youtube.com/watch?v=NNCWMFT1e24)

0(1) по времени на каждую операцию.

0. Наивное решение - держать элементы стека например в std::vector - push 
- push_back, рор() - рор_back(), tор() - back(), getMin - идём по всем
элементам и находим минимум.

push - amortized O(1), рор - O(1), top() - O(1), getMin - O(n), n - число 
элементов в текущем стеке.

0b. - хранить множество (std::set) из текущих элементов - находим минимум за О(log(n)), n - текущее число элементов в стеке.

1. Общий подход: 

держать 2 стека. В одном собственно элементы, во втором - минимумы на текущий момент.

Когда добавляем элемент - знаем минимум от всех элементов, кроме нового - 
и по старому минимуму и новому элементу - можем найти значение нового 
минимума. O(1) находится

Когда убираем - убираем и из стеке минимумов последний элемент - возвращаемся к стеку минимумов для меньшего размера стека.

Получение минимума - верхний элемент второго стека.

values[]  
mins[]

push(-2)

values[-2]  
mins[-2]

push(0)

values[-2,0]  
mins[-2,-2]

push(-3)

values[-2,0,-3]  
mins[-2,-2,-3]

getMin -> -3

pop()

values[-2,0]  
mins[-2,-2]

2. Реализация: 

какой контейнер взять?

vector 
deque
1ist

vector: push_back - O(1) amortized
deque: push_back - O(1) amortized, возможно рор_back тоже O(1) amortized 
list: если выделение памяти O(1), то push_back делается за O(1) чистый.

std::stack - адаптер, по умолчанию использует std::deque 

std::stack<int,std::list<int>>

3. Использовать два отдельных стека - под значения и минимумы - или один стек из struct с двумя полями.

Один стек из struct:
- экономим в 2 раза количество new в list  
- в каждом элементе list 2 указателя - если один элемент list вместо двух  - экономим два указателя.  
- выравнивание в памяти. int - 4 байта, указатели по 8 байт, размер элемента динамической памяти округляется до кратного 8 байтам -

4+8+8 = 20 -> 24 * 2 = 48

