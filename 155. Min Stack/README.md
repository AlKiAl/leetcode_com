https://leetcode.com/problems/min-stack/

https://walkccc.me/LeetCode/problems/0155/

________

[Разбор задачи 155 leetcode.com Min Stack. Решение на C++](https://www.youtube.com/watch?v=NNCWMFT1e24)

0(1) по времени на каждую операцию.

0. Наивное решение - держать элементы стека например в std::vector: push() - push_back(), рор() - рор_back(), tор() - back(), getMin - идём по всем элементам и находим минимум.

push - amortized O(1), рор - O(1), top() - O(1), getMin - O(n), n - число элементов в текущем стеке.

0b. - хранить множество (std::set) из текущих элементов - находим минимум за О(log(n)), n - текущее число элементов в стеке.

1. Общий подход: 

держать 2 стека. В одном собственно элементы, во втором - минимумы на текущий момент.

Когда добавляем элемент - знаем минимум от всех элементов, кроме нового - 
и по старому минимуму и новому элементу - можем найти значение нового 
минимума. O(1) находится

Когда убираем - убираем и из стеке минимумов последний элемент - возвращаемся к стеку минимумов для меньшего размера стека.

Получение минимума - верхний элемент второго стека.

values[]  
mins[]

push(-2)

values[-2]  
mins[-2]

push(0)

values[-2,0]  
mins[-2,-2]

push(-3)

values[-2,0,-3]  
mins[-2,-2,-3]

getMin -> -3

pop()

values[-2,0]  
mins[-2,-2]

2. Реализация: 

какой контейнер взять?

vector  
deque  
list

vector: push_back - O(1) amortized  
deque: push_back - O(1) amortized, возможно рор_back тоже O(1) amortized  
list: если выделение памяти O(1), то push_back делается за O(1) чистый.

std::stack - адаптер, по умолчанию использует std::deque 

std::stack<int,std::list<int>>

3. Использовать два отдельных стека - под значения и минимумы - или один стек из struct с двумя полями.

Один стек из struct:
- экономим в 2 раза количество new в list  
- в каждом элементе list 2 указателя - если один элемент list вместо двух  - экономим два указателя.  
- выравнивание в памяти. int - 4 байта, указатели по 8 байт, размер элемента динамической памяти округляется до кратного 8 байтам -

4+8+8 = 20 -> 24 * 2 = 48  
4+4+8+8=24

Если указатель 8 байтов - выигрыш от использования struct в 2 раза. 

4. А не написать ли свою структуру?

vector - как идеал структуры, которая мало использует вызовы к диспетчеру кучи. 
Единственное, что не устраивает в этой задаче - amortized - что иногда нужно копировать элементы из предыдущего стека в новый. 
В этот момент количество действий может быть большое.

Что делать: отложенные операции. Хранить 2 стека. 

Если память любого объёма можно выделить за O(1). 

4b. Ещё один вариант своей структур - список из массивов.
Чистый O(1) на создание элемента. 
При этом накладные расходы на один push в 128 раз меньше.
