class Solution {

public:

  int trap(vector<int>& h) {
      int maxpos = 0; // предполагаем, что высота первого элемента максимальна, и устанавливаем его индекс 0 в переменную maxpos
  
      // поиск первого вхождения максимума
      for (int i = 0; i < h.size(); ++i) { // пробегаем по индексам всех элементов (блоков)
          if (h[i] > h[maxpos]) { // если значение текущего элемента больше (>) значения элемента с индексом maxpos (0-индекс первого оборота):
              maxpos = i; // перезаписываем индекс максимального элемента и устанавливаем индекс текущего элемента
          }
      }
  
      int ans = 0; // устанавливаем значение (0) для новой переменной ответа (здесь мы собираем блоки воды)
      int nowm = 0; // устанавливаем значение (0) - для новой переменной nowm (новый максимум)
      for (int i = 0; i < maxpos; ++i) { // пробегаем по индексам всех элементов слева до нашего maxpos (индекс максимального элемента)
          if (h[i] > nowm) { // если значение текущего элемента больше (>) значения элемента nowm (0 - первый оборот):
              nowm = h[i]; // устанавливаем значение текущего элемента переменной nowm
          }
          ans += nowm - h[i]; // добавляем к общему значению блоков воды (переменной ans) разницу между nowm (новым максимумом) и текущим элементом
      }
  
      nowm = 0; // снова устанавливаем значение (0) - для новой переменной nowm (новый максимум)
      for (int i = h.size() - 1; i > maxpos; --i) { // пробегаем по индексам всех элементов справа до нашего maxpos (индекс максимального элемента)
          if (h[i] > nowm) { // если значение текущего элемента больше (>) значения элемента nowm (0 - первый оборот):
              nowm = h[i]; // устанавливаем значение текущего элемента переменной nowm
          }
          ans += nowm - h[i]; // добавляем к общему значению блоков воды (переменной ans) разницу между nowm (новым максимумом) и текущим элементом
      }
  
      return ans; // возвращаем значение общего количества блоков воды
  }


};
