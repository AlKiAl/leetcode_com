my_code.cpp по сути аналог 279b.cpp, просто более раписаный, обобщенный

________

https://leetcode.com/problems/perfect-squares/ <-- Теорема Лагранжа о сумме четырёх квадратов

https://walkccc.me/LeetCode/problems/0279/ -- аналог 279b.cpp

[Разбор задачи 279 leetcode.com Perfect Squares. Решение на C++](https://www.youtube.com/watch?v=yUqNob_zPIg)

Аналог: https://contest.yandex.ru/contest/45469/problems/21/

```objectives
#include<iostream>
#include<vector>

using namespace std;

int main() {

	int N;
	cin >> N;

	if (N < 8) { cout << N; return 0; }

	vector<int> DP(N+1, 101); // DP[i] == наименьшее число слагаемых в кубическом разложении числа i : i \in |N --> искомое == DP.back()
	DP[0] = 0;

     for (int sum = 1; sum <= N; sum++) {
       for (int first = 1; first * first * first <= sum; first++) { // first * first <= sum <-->  0 <= sum - first * first -- что используется далее в nSq[sum - first * first]
         
         // min -- по условию задачи
         DP[sum] = min(DP[sum],  DP[sum - first * first * first] + 1 );   // "+ 1" обусловлен тем, что из "sum - first * first" можно получить "sum" 
         // добавлением одного perfect square = first * first -- значит количество слагаемых увеличивается на 1
         
       } 
    }


	cout << DP.back();
}
```
_______________________

0. Наивное решение.

Перебираем первое слагаемое - и рекурсивно вызываем перебор
от того, что осталось - выбираем лучший вариант.

13 -> 1+[12]  
13 -> 4+[9]  
13 -> 9+[4]  
13 -> 1б+? -не вариант  

Перебор первого слагаемого О(sqrt(n)) -- ассимптотика такая ввиду того, что перебираем квадраты натуральных чисел от 1 до n 

Общая сложность перебора от количества слагаемых. 

Ответ от 1 до 4 -- [Теорема Лагранжа о сумме четырёх квадратов](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%9B%D0%B0%D0%B3%D1%80%D0%B0%D0%BD%D0%B6%D0%B0_%D0%BE_%D1%81%D1%83%D0%BC%D0%BC%D0%B5_%D1%87%D0%B5%D1%82%D1%8B%D1%80%D1%91%D1%85_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%BE%D0%B2).

О(sqrt(n))  перебираем первое слагаемое  
О(sqrt(n)) перебираем второе слагаемое  
О(sqrt(n)) перебираем третье слагаемое  
если что-то осталось - за O(1) можно определить, это полный квадрат или нет.

O(n^1.5) по времени  
O(1) по памяти

1. ДП

Решаем исходную задачу для всех чисел от 0 до n. Массив

Перебираем последнее слагаемое, вычитаем его.

Два варианта порядка циклов  
а) внешний - по числу раскладываемому, внутренний - по последнему слагаемому.  
б) можно поменять циклы местами. Решаем задачу, разрешая всё бОльшие слагаемые.

Количество действий в этих варианта одинаковое - доступ к  памяти лучше в варианте б)

0(n^1.5) по времени  
0(n) по памяти

Возможно у ДП константа у времени лучше.

2. Секретный способ O(sqrt(N))

Реализация не предоставляется 
_________________________________________

279a.cpp

veleboks, [7/9/2023 12:46 PM]
квадрат, наверное. (грубая оценка)

Erik, [7/9/2023 12:49 PM]
Почему? Там максимум 4 раза в рекурсию войдет и не более чем sqrt(n) будет в цикле

Erik, [7/9/2023 12:50 PM]
А пон, я дурачек

Erik, [7/9/2023 12:50 PM]
Квадрат, да

