
https://leetcode.com/problems/find-all-anagrams-in-a-string/description/

https://walkccc.me/LeetCode/problems/0438/

примечательно то, что [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/description/) 
следует из 438. Find All Anagrams in a String, необходимо лишь изменять возвращаемый тип

438. Find All Anagrams in a String --> 567. Permutation in String --> 242. Valid Anagram

[Разбор задачи 438 leetcode.com Find All Anagrams in a String. Решение на C++](https://www.youtube.com/watch?v=VKB7q3Sfjuk&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)

________

1. Наивный алгоритм. Перебираем места в s, к которым можно "приставить" р - и выясняем для этой подстроки и для р - являются ли они анаграммами.

Анаграмма - для каждой буквы её количество в одной и другой совпадает.

ааЬсс          Ьасас

Всю информацию об анаграмме можем хранить как информацию для каждой буквы словаря, сколько таких букв есть в строке.

Сложность сравнения двух строк: 0(len+alphabet) - вариант с массивом (быстрее). Если в таблице обращаться только к используемым буквам, 0(1егi) - вариант с хэш-таблицей (медленнее).

Длина до 20 тыс. Худший случай - когда анаграммы большие и их много. Размер одной - Iрi, количество - тах(0,Is1-Iр1+1)

Худший случай - 1s1 максимальный, iрi - 151/2.
20000 - длина s, 10000 - длина р. Порядка 10000 сравнений,  r на одно сравнение порядка 10000 действий. Порядка 100 млн 
операций. Один тест - в 1 с вписался бы. Обычно на 1еесоде много тестов в одной задаче - и общий ТС - на прохождение всех этих тестов. Прохождение возможно, но маловероятно.

2. Оптимизация. 

cbaebabacd  
- - -  
 - - -  

аЬс  
- - -  

В терминах статистики какой буквы сколько при сдвиге окна на 1 букву - нужно убрать одну букву и добавить одну букву.

Это можно сделать за 0(1) на сдвиг окна независимо от размера р.

Считать статистику не надо, но надо сравнивать статистику окна и р.

Действий O(|p| + (|s|- |p|)(alphabet)

В этом вариант худший случай, когда |p| = 1. 20000 * 26 =520.000 ~ 500 тыс действий. Можем себе позволить.

3. Оптимизация 2.

Отвязываемся от размера алфавита.


