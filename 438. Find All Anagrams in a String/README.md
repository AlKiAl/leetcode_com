
https://leetcode.com/problems/find-all-anagrams-in-a-string/description/

https://walkccc.me/LeetCode/problems/0438/

примечательно то, что [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/description/) 
следует из 438. Find All Anagrams in a String, необходимо лишь изменять возвращаемый тип

438. Find All Anagrams in a String --> 567. Permutation in String --> 242. Valid Anagram

-----------

438b.cpp -- оптимизированный аналог my_code_sliding_window.cpp

438с.cpp -- самый оптимальный

438d.cpp <--> 438e.cpp с той разницей, что в 438d.cpp используется long long, а в 438e.cpp - unsigned 

[Разбор задачи 438 leetcode.com Find All Anagrams in a String. Решение на C++](https://www.youtube.com/watch?v=VKB7q3Sfjuk&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)

________

1. Наивный алгоритм.

Перебираем места в s, к которым можно "приставить" р - и выясняем для этой подстроки и для р - являются ли они анаграммами.

Анаграмма - для каждой буквы её количество в одной и другой совпадает: ааЬсс          Ьасас

Всю информацию об анаграмме можем хранить как информацию для каждой буквы словаря, сколько таких букв есть в строке.

Сложность сравнения двух строк: O(len+alphabet) - вариант с массивом (быстрее). 
Если в таблице обращаться только к используемым буквам, O(len) - вариант с хэш-таблицей (медленнее).

Длина до 20 тыс. Худший случай - когда анаграммы большие и их много. Размер одной - |p|, количество - max(0, |s|- |p| + 1)

Худший случай - |s| максимальный, |p| ~ |s|/2.

20000 - длина s, 10000 - длина р. Порядка 10000 сравнений, на одно сравнение порядка 10000 действий. Порядка 100 млн операций. 
Один тест - в 1 сек. вписался бы. 
Обычно на leetcode много тестов в одной задаче - и общий TL - на прохождение всех этих тестов. Прохождение возможно, но маловероятно.

2. Оптимизация. 

| c 	| b 	| a 	| e 	| b 	| a 	| b 	| a 	| c 	| d 	|
|---	|---	|---	|---	|---	|---	|---	|---	|---	|---	|
| - 	| - 	| - 	|   	|   	|   	|   	|   	|   	|   	|
|   	| - 	| - 	| - 	|   	|   	|   	|   	|   	|   	|

| a 	| b 	| c 	|
|---	|---	|---	|
| - 	| - 	| - 	|

В терминах статистики какой буквы сколько при сдвиге окна на 1 букву - нужно убрать одну букву и добавить одну букву.

Это можно сделать за 0(1) на сдвиг окна независимо от размера р.

Считать статистику не надо, но надо сравнивать статистику окна и р.

Действий O(|p| + (|s|- |p|)(alphabet)

В этом вариант худший случай, когда |p| = 1. 20000 * 26 =520.000 ~ 500 тыс действий. Можем себе позволить.

3. Оптимизация 2.

Отвязываемся от размера алфавита.

Можно посчитать, для скольких букв есть различие статистики. 
Когда меняется статистика для одной буквы - обновляем этот счётчик.

Обновление счётчика за O(1) и проверка "0 разпичий" = анаграмма - тоже O(1)

Действий O(|s| + |p|) - Худший случай 40.000 операций, более тяжёлых, чем в случае 2. 
Будет быстрее, чем 2, но не в 10 раз.

4. Оптимизация 3 

можно не иметь две статистики - по p и по окну в s - а по р добавлять статистику с плюсом, по окну s с минусом - экономия в 2 раза по памяти,  
возможно чуток s с минусом - экономия в 2 раза по памяти, возможно чуток по времени.

5. Полиномиальные хэши (?)

Предложение - выбрать относительно случайные множители для букв. 
Допустим 1оп 1оп, для каждой буквы - случайное число от 1е14 до 2е14. 
Будем считать сумму букв с такими коэффициентами. +1 буква - добавляем в сумму, -1 буква - вычитаем из суммы.

Вероятность другой комбинации дать ту же сумму 1/диапазон, где может лежать сумма. В первом приближении 
вероятность коллизии —10^-18. 10000 сравнений - вероятность коллизии во всей программе ~ 10^-14.

_______

А Б, [7/14/2023 10:03 PM]
Если нужно будет условие / полный контекст — дайте знать, а пока, вопрос: 

Есть функция

    unsigned* getKoef() {
        static unsigned koef[1 + 'z'] = {};
        if (koef[0] == 0) {
            mt19937 gen(2202);
            for (char c = 'a'; c <= 'z'; c++) {
                koef[c] = uniform_int_distribution<unsigned>(1e9, 2e9)(gen);
            }
        }
        return koef;
    }

Я знаю по отднльности и про указатаель и про static, но вот как-то в связке мне не очень понятно (если убрать static, код упадет). Хотел бы комментариев по поводу  unsigned* и  static unsigned koef[1 + 'z'] = {}; в связке что-ли, не понятно, поему падает, если убрать стетик, и какой в целом возвращаемый тип, если уйти от указателей...

Alexander Pshenichnikov, [7/14/2023 10:07 PM]
Вы возвращаете из функции указатель на буфер koef, если он static, то все хорошо, он продолжает жить после выхода из функции. Без статик время жизни массива заканчивается с выходом из функции

ОБНВ: без статик компилятор скорее всего напишет вам warning, что вы возвращаете указатель на локальную переменную

А Б, [7/14/2023 10:09 PM]
так, окей, спасибо, а любопытсва ради, можно как-то ибавиться от static и указателя? Вероятно, просто скопировать, но тогда какой возвращаемый тип будет у функции?

Alexander Pshenichnikov, [7/14/2023 10:10 PM]
Возвращайте смарт поинтер на массив, или std::vector<unsigned>

А Б, [7/14/2023 10:12 PM]
" смарт поинтер на массив" — можно подобнее?_

Alexander Pshenichnikov, [7/14/2023 10:14 PM]
Вот например, смотрите  (2)

https://en.cppreference.com/w/cpp/memory/unique_ptr

Но подумайте лучше про vector

Graceful Phoenix, [7/14/2023 10:20 PM]
Функция возвращает указатель на статический массив. Он хранит натуральные числа, каждое из которых - случаяная величина, равномерно распределённая в диапазоне от милларда до двух миллирдов. Я так понимаю, что в качестве индексов хотят использовать буквы латинского алфавита, от a до z, только туда и записывают эти числа. А по индексам от 0 до 'a'-1 видать ничего нет. Хмь. Но почему же условие перегенерации массива - 0 по индексу 0.

_______

Примечательно то, что если использовать

    auto getKoef() {
        static unsigned koef[1 + 'z'] = {};
        if (koef[0] == 0) {
            mt19937 gen(2202);
            for (char c = 'a'; c <= 'z'; c++) {
                koef[c] = c   + 137;
            }
        }
        return koef;
    }

то упадет на 51 / 65 testcases passed s = "af" p = "be" -- это коллизия?
