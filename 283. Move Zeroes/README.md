https://leetcode.com/problems/move-zeroes/

https://walkccc.me/LeetCode/problems/0283/

________

[Разбор задачи 283 leetcode.com Move Zeroes. Решение на C++](https://www.youtube.com/watch?v=oIJ5qG1CPz0)

0 Сортировка пузырьком 

________

Имеет место очевидная формула: $LastIdxNotZero + CountZero = i$, где

$i$ - индекс $nums$

$CountZero$ - количество нулей в префиксе $nums$, в диапозоне индексов от 0 до $i$

$LastIdxNotZero$ - количество НЕ нулей в префиксе $nums$, в диапозоне индексов от 0 до $i$

Примечательно, что решение my_code_with_CountZero.cpp схоже с Create my_code_without_unique.cpp задачи 26. Remove Duplicates from Sorted Array

_________

Здравствуйте! Огромное вам спасибо за разбор задач! Только начинаю вникать в тему программирования и поэтому возникает куча "почему" и "как". У меня возник вопрос по задаче 283 вариант с: в строке 11 у нас происходит вроде не присваивание, а копирование значения элемента a[i]?! Чтобы произвести присваивание стоит, наверное, использовать move? С ним у меня показатели по времени и памяти вроде лучше, чем без него. Буду благодарна вам за обратную связь.

std::move для int'ов не делает вообще ничего. Она облегчает перенос для чего-то, у чего внутренность лежит в динамической памяти. Тогда приёмник может получить ссылку на внутренность того, откуда идёт перенос. И тогда реально копирования основной части данных не происходит. Например в vector, map и похожих контейнерах. Нужно всего лишь понимать как контейнеры внутри устроены. Например у std::array нет указателей внутри - и std::move для него ничего не сможет сделать. Как и для любого элементарного типа, как и для структуры без указателей. Однако если структура с указателями создана Вами лично, то опять же недостаточно написать move, нужно ещё и методы обработки написать - move constructor, move assignment operator.
