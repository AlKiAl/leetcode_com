https://leetcode.com/problems/move-zeroes/

https://walkccc.me/LeetCode/problems/0283/

________

[Разбор задачи 283 leetcode.com Move Zeroes. Решение на C++](https://www.youtube.com/watch?v=oIJ5qG1CPz0)

0. Сортировка пузырьком

Как не надо делать:

O(N^2)

Бежим по массиву, когда встречаем не ноль - начинаем его двигать влево, обменивая с нулём слева от него, пока не станет, что нуля слева нет.

[0,1,0,3,12]

[1,0,0,3,12]

[1,0,3,0,12]

[1,3,0,0,12]

[1,3,0,12,0]

[1,3,12,0,0]

Худший случай - когда ненулевых элементов N/2 и они все в конце - каждый придётся двигать примерно на N/2, итого (N/2)^2 ~ O(N^2)


N=10^6 действий .10^12.

1. 0(N) решение 1 - обмен элементов.

Нужно помнить, где первый ноль. Идём по массиву, встречаем ненулевой элемент - обмениваем его спервым нулем

Первые ненулевые элементы: или пропустить отдельным циклом, или обменять с собой.

\* == куда пишем  
^ == откуда читаем

|   	| * 	|   	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	| ^ 	|   	|   	|   	|    	|   	|

|   	|   	| * 	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	| ^  	|   	|   	|    	|   	|

|   	|   	| * 	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	| ^ 	|   	|    	|   	|

|   	|   	| * 	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	| ^  	|    	|   	|

|   	|   	|  	  | * 	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 0 	| 0 	| 12 	| ] 	|
|   	|   	|   	|   	|   	| ^   |   	|

|   	|   	|  	  | * 	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 0 	| ] 	|
|   	|   	|   	|   	|   	|     | ^  	|

Количество действий: O(N)

Чтений: N  
Обменов: nonzero

Если один обмен - это три присваивания - то присваиваний в худшем случае 3N.

Этот вариант очень хорош, когда нулей много.

2. Всё то же самое, как и в варианте 1, но присваиваем, а не обмениваем, а в конце зануляем хвост массива.

|   	| * 	|   	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	| ^ 	|   	|   	|   	|    	|   	|

|   	|   	| *  	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	| ^  	|   	|   	|    	|   	|

|   	|   	| *  	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	| ^  	|   	|    	|   	|

|   	|   	| *  	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 0 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	| ^  	|    	|   	|

|   	|   	| *  	|   	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	| ^  	|    	|   	|

|   	|   	|   	| *  	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	| ^  	|    	|   	|

|   	|   	|   	| *  	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 0 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	|   	| ^  	|   	|

|   	|   	|   	| *  	|   	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	|   	| ^  	|   	|

|   	|   	|   	|   	| *  	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 3 	| 12 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

|   	|   	|   	|   	| *  	|    	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 12 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

|   	|   	|   	|   	|   	| *  	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 12 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

|   	|   	|   	|   	|   	| *  	|   	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 0 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

|   	|   	|   	|   	|   	|   	| *  	|
|---	|---	|---	|---	|---	|----	|---	|
| [ 	| 1 	| 3 	| 12 	| 0 	| 0 	| ] 	|
|   	|   	|   	|   	|   	|   	| ^  	|

Чтений: N  
Присваиваний: N

_________

Здравствуйте! Огромное вам спасибо за разбор задач! Только начинаю вникать в тему программирования и поэтому возникает куча "почему" и "как". У меня возник вопрос по задаче 283 вариант с: в строке 11 у нас происходит вроде не присваивание, а копирование значения элемента a[i]?! Чтобы произвести присваивание стоит, наверное, использовать move? С ним у меня показатели по времени и памяти вроде лучше, чем без него. Буду благодарна вам за обратную связь.

std::move для int'ов не делает вообще ничего. Она облегчает перенос для чего-то, у чего внутренность лежит в динамической памяти. Тогда приёмник может получить ссылку на внутренность того, откуда идёт перенос. И тогда реально копирования основной части данных не происходит. Например в vector, map и похожих контейнерах. Нужно всего лишь понимать как контейнеры внутри устроены. Например у std::array нет указателей внутри - и std::move для него ничего не сможет сделать. Как и для любого элементарного типа, как и для структуры без указателей. Однако если структура с указателями создана Вами лично, то опять же недостаточно написать move, нужно ещё и методы обработки написать - move constructor, move assignment operator.

________

Имеет место очевидная формула: $LastIdxNotZero + CountZero = i$, где

$i$ - индекс $nums$

$CountZero$ - количество нулей в префиксе $nums$, в диапозоне индексов от 0 до $i$

$LastIdxNotZero$ - количество НЕ нулей в префиксе $nums$, в диапозоне индексов от 0 до $i$

Примечательно, что решение my_code_with_CountZero.cpp схоже с Create my_code_without_unique.cpp задачи 26. Remove Duplicates from Sorted Array
