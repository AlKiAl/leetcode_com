задачи были одна вот эта,  https://leetcode.com/problems/subarray-sum-equals-k/ Только надо было вернуть не длину, а индексы
___________

https://leetcode.com/problems/subarray-sum-equals-k/

https://walkccc.me/LeetCode/problems/0560/  

https://www.geeksforgeeks.org/number-subarrays-sum-exactly-equal-k/

_____

PS[i] - k = PS[j] : k == Affix[j, ..., i + 1], 0 <= j < nums.size()  
Тогда, сумма количеств PS[j] и будет ответом

_____


[Разбор задачи 560 leetcode.com Subarray Sum Equals K. Решение на C++](https://www.youtube.com/watch?v=UWPKvrproqQ&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)

560a.cpp -- тривиальная реализация алгоритма 2 через unordered_map  
560b.cpp -- улучшение 560a.cpp  
560с.cpp -- аналог 560b.cpp с наличием ускорялки  
560d.cpp -- 560b.cpp через map

0. O(n^3)

Наивный подход 

- перебираем индексы начала и конца подмассива, явно проходим по нему и суммируем, сравниваем с k.

20.000^3 = 8е12. 3а 1 секунду успеваем сделать 1е8-1е9 операций.

Время работы ~ Часы.

1. O(n^2). 

Можем не идти по подмассиву, можем за O(1) посчитать сумму - заранее посчитать массив интегральных сумм.

O(n^2) по времени

20.000^2 = 4е8. 3а 1 секунду успеваем сделать 1е8-1е9 может и подходит, но: 
на leetcode запускается программа сразу с несколькими тестами - и всё целиком замеряется.

Если хотя бы 10 тестов по 20.000 - отработает за несколько секунд, хорошие шансы, что получим ТLЕ не leetcode.

2. O(n). 

зафиксировали конец подмассива. Хотим узнать количество начал, таких что сумма подмассива равна k. 
Если исходить из алгоритма (1) с интегральными суммами - то нам 
нужно количество начал (префиксов), у которых сумма на k меньше, чем у текущего префикса.

Можем для каждой суммы префикса отслеживать, сколько есть таких префиксов.

Когда рассматриваем очередной префикс, из его суммы вычитаем k - и смотрим, сколько префиксов имеют такую сумму.

3а O(1) решаем задачу для одной позиции конца подмассива.

O(n) в целом. Ожидаемая сложность.  
O(1) искать по map - unordered_map - хэш-таблица   
O(size) в худшем случае поиск. Ожидаемое O(1).

O(n) ожидаемое   
O(n^2) худший случай с std::unordered_map

О(nlogn) гарантированный с std::map 

O(n) по памяти

____

 ищем не количество сумм элементов равных k, а ищем количество префиксов, у которых сумма на k меньше, чем у текущего префикса. Пойду читать про интегральные суммы 

____

<p align="center"> My ex 1 </p>

nums = [0,1,-1,2], k = 2  
3  
0 + 1 + (-1) + 2 = 2  
1 + (-1) + 2 = 2  
2 = 2


<p align="center"> My ex 2 </p>

nums = [2], k = 2  
1

<p align="center"> My ex 3 </p>

k = 2

| idx       	|   	|   	| 0  	| 1  	| 2  	| 3  	| 4  	| 5  	| 6  	|
|-----------	|---	|---	|----	|----	|----	|----	|----	|----	|----	|
| nums      	|   	|   	| 42 	| 1  	| 1  	| 1  	| 2  	| 0  	| 0  	|
| PrefixSum 	|   	| 0 	| 42 	| 43 	| 44 	| 45 	| 47 	| 47 	| 47 	|
| Ans       	|   	|   	| 0  	| 0  	| 1  	| 2  	| 3  	| 4  	| 5  	|


<p align="center"> My ex 4 </p>

k = 0

| idx       	|   	|   	| 0  	| 1  	| 2  	|
|-----------	|---	|---	|----	|----	|----	|
| nums      	|   	|   	| -1 	| -1 	| 1  	|
| PrefixSum 	|   	| 0 	| -1 	| -2 	| -1 	|
| Ans       	|   	|   	| 0  	| 0  	| 1  	|
