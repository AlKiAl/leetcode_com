https://leetcode.com/problems/accounts-merge/description/

https://walkccc.me/LeetCode/problems/721/

<img src="https://github.com/SkosMartren/useful-materials/blob/main/721_1.png" width="1200" height="600"/>

                                                              // фото показывает построение графика и последующее сляиние через DFS
                                                             for (vector<string>& account : accountList) {
                                                                
                                                                const string accountFirstEmail = account[1];
                                                                for (int j = 2; j < account.size(); j++) {
                                                                    string email = account[j];
                                                                    
                                                                    adjacent[email].push_back(accountFirstEmail);
                                                                    adjacent[accountFirstEmail].push_back(move(email));
                                                                }
                                                            }

https://t.me/algoses/213

    Задача Яндекса. 
    
    Имеется n пользователей, каждому из них соответствует список email-ов (всего m email-ов). Например:
    user1 -> xxx@ya.ru, foo@gmail.com, lol@mail.ru  
    user2 -> foo@gmail.com, ups@pisem.net  
    user3 -> xyz@pisem.net, vasya@pupkin.com  
    user4 -> ups@pisem.net, aaa@bbb.ru  
    user5 -> xyz@pisem.net
    
    Считается, что если у двух пользователей есть общий email, значит это один и тот же пользователь.
    
    Требуется построить и реализовать алгоритм, выполняющий слияние пользователей. На выходе должен быть список пользователей с их email-ами (такой же как на входе).
    
    В указанном примере ответ на задачу будет следующий:
    user1 -> xxx@ya.ru, foo@gmail.com, lol@mail.ru, ups@pisem.net, aaa@bbb.ru  
    user3 -> xyz@pisem.net, vasya@pupkin.com  
    
    Решение: 
    
    Честно говоря, задача прикольная. С одной стороны, простая, а с другой — можно легко уйти не туда. 
    
    Подумаем про графы. Было бы хорошо выделить юзеров отдельно и множество почт отдельно. 
    
    Давайте визуально нарисуем слева вершины, которые соответствуют юзерам. В нашем примере их 5. 
    
    А справа выпишем множество различных почт. 
    
    После из каждой вершины слева проведем ребро к вершине справа, если у определенного юзера есть такая-то почта. Например, из вершины слева, которая отвечает за user1, проведется три ребра в правую сторону. 
    
    Если кто не понял, то это двудольный граф. И вся задача сводится к тому, чтобы найти количество компонент связностей. То есть делаем просто обход графа и запоминаем набор юзеров, которые посетили, и набор почт. 
    
    Например, запускаем ДФС с вершины user1 и посещаем вершины user2, user4, xxx@ya.ru, foo@gmail.com, lol@mail.ru, ups@pisem.net. В качестве ответа вы берете любого юзера и все почты, которые успели посетить. Дальше запускаете ДФС от непосещенной вершины (это вершина user3) и запускаете ДФС.
    
    Единственное вам нужно пронумеровать вершины. Вы можете завести словарь куда будете писать номер вершины которому соответствует строка. Например 
    'user1' - 0, 
    'user2' - 1, 
    'xxx@ya.ru - 2' 
    .......
    То есть каждой строке дать число. Зачем мы это делаем??? 
    Попробуйте построить граф на строках и написать дфс, думаю веселье такое себе. Так что пишем словарь который будет строки переводить в числа. Также полезно создать еще один словарь, который будет по индексу вершины узнавать что за строка. Например из примера выше для индекса 2 соответствует строка xxx@ya.ru. 
    
    Асимптотика линейная.
