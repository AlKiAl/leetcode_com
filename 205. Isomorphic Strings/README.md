В теории множеств любая биекция является изоморфизмом.

my_code_bijection.cpp == 205a.cpp

Изоморфизм на множестве символов строк == биекция, пусть есть множество S и T, будем устнавливать между ними связь через доп. множество-фильтр Idx, т.е. S --> Idx, T --> Idx, и если между элементами S и T биекция, то оба этих элемента проходят через один и тот же элемент в Idx
__________

https://leetcode.com/problems/isomorphic-strings/

https://walkccc.me/LeetCode/problems/0205/

__________

[Разбор задачи 205 leetcode.com Isomorphic Strings. Решение на C++](https://www.youtube.com/watch?v=a793ad7hmao)

Два unordered_mар / vector - индекс - буква в одном слове, значение - буква в другом слове.

Получаем новую пару буква1-буква2 - смотрим в этих таблицах, сопоставлено ли что-то букве1, и сопоставлено ли что-то букве2.

Если нет сопоставления - добавляем.

Вариант unordered_mар:  
о(|s|) - по времени  
O(min(|s|, |alphabet|)) - по памяти  

Вариант vector:  
O(|s|+|alphabet|) - по времени  
O(|alphabet|) - по памяти

Если алфавит небольшой:  
O(|s|) по времени  
O(1) по памяти

__________

| Idx 	|   	| 0 	| 1 	| 2 	| 3 	| 4 	|
|:---:	|:-:	|:-:	|:-:	|:-:	|---	|---	|
|  s  	|   	| p 	| a 	| p 	| e 	| r 	|
|  t  	|   	| t 	| i 	| t 	| l 	| e 	|
|     	|   	|   	|   	|   	|   	|   	|
|     	|   	|   	|   	|   	|   	|   	|
