https://leetcode.com/problems/longest-increasing-subsequence/description/

https://walkccc.me/LeetCode/problems/300/

https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/

For each number in nums, we perform the following steps:

If the number is greater than the last element of the last bucket (i.e., the largest element in the current subsequence), we append the number to the end of the list. This indicates that we have found a longer subsequence.
Otherwise, we perform a binary search on the list of buckets to find the smallest element that is greater than or equal to the current number. This step helps us maintain the property of increasing elements in the buckets.
Once we find the position to update, we replace that element with the current number. This keeps the buckets sorted and ensures that we have the potential for a longer subsequence in the future.

Для каждого числа в nums мы выполняем следующие действия:

Если число больше, чем последний элемент последнего сегмента (т.е. самый большой элемент в текущей подпоследовательности), мы добавляем это число в конец списка. Это указывает на то, что мы нашли более длинную подпоследовательность.
В противном случае мы выполняем бинарный поиск в списке сегментов, чтобы найти наименьший элемент, который больше или равен текущему номеру. Этот шаг помогает нам сохранить свойство увеличения элементов в сегментах.
Как только мы находим позицию для обновления, мы заменяем этот элемент текущим номером. Это обеспечивает сортировку сегментов и гарантирует, что в будущем у нас будет возможность использовать более длинную подпоследовательность.

---

- Давайте разберём эту идею на примере.

- Рассмотрим пример nums = [2, 6, 8, 3, 4, 5, 1], попробуем построить возрастающие подпоследовательности, начиная с пустой: sub1 = [].

  1. Берём первый элемент, sub1 = [2].
  2. 6 больше предыдущего числа, sub1 = [2, 6].
  3. 8 больше предыдущего числа, sub1 = [2, 6, 8].
  4. 3 меньше предыдущего числа, мы не можем расширить подпоследовательность sub1, но должны сохранить 3, так как в будущем может быть самая длинная подпоследовательность, начинающаяся с [2, 3], sub1 = [2, 6, 8], sub2 = [2, 3].
  5. С 4 мы не можем расширить sub1, но можем расширить sub2, так что sub1 = [2, 6, 8], sub2 = [2, 3, 4].
  6. С 5 мы не можем расширить sub1, но можем расширить sub2, так что sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5].
  7. С 1 мы не можем расширить ни sub1, ни sub2, но должны сохранить 1, так что sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5], sub3 = [1].
  8. В итоге, длина наибольшей возрастающей подпоследовательности = len(sub2) = 4.

- В приведённых шагах нам пришлось хранить несколько подмассивов (sub1, sub2..., subk), что снижает производительность. Однако можно хранить только один массив sub: если новое число x не больше последнего элемента sub, мы выполняем бинарный поиск, чтобы найти наименьший элемент >= x в sub, и заменяем его на x.

- Запустим этот пример nums = [2, 6, 8, 3, 4, 5, 1] снова:

  1. Берём первый элемент, sub = [2].
  2. 6 больше предыдущего числа, sub = [2, 6].
  3. 8 больше предыдущего числа, sub = [2, 6, 8].
  4. 3 меньше предыдущего числа, мы не можем расширить подпоследовательность sub. Нужно найти наименьшее число >= 3 в sub, это 6. Затем мы заменяем его, теперь sub = [2, 3, 8].
  5. 4 меньше предыдущего числа, так что мы не можем расширить подпоследовательность sub. Мы заменяем 8 на 4, так что sub = [2, 3, 4].
  6. 5 больше предыдущего числа, sub = [2, 3, 4, 5].
  7. 1 меньше предыдущего числа, так что мы не можем расширить подпоследовательность sub. Мы заменяем 2 на 1, так что sub = [1, 3, 4, 5].
  8. В итоге, длина наибольшей возрастающей подпоследовательности = len(sub) = 4.
