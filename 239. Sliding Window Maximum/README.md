https://leetcode.com/problems/sliding-window-maximum/description/

https://walkccc.me/LeetCode/problems/239/

У Федора Меньшикова разбор отсут-т!

____

Объяснение кода:
* Инициализация:

result: Вектор, в который будут добавляться максимальные значения для каждого положения окна.  
windowIndices: Дек, который будет хранить индексы элементов в текущем окне.


* Основной цикл:

Проходим по всем элементам массива nums с помощью индекса i.

* Обновление дек (очередь):

Внутренний цикл while: удаляем из дека индексы тех элементов, которые меньше текущего элемента nums[i]. Эти элементы не могут быть максимумом в текущем окне, так как текущий элемент больше их и находится в текущем окне.

* Добавление текущего индекса:

Добавляем текущий индекс i в дек.

* Удаление старых индексов:

Если индекс, находящийся в начале дека (самый старый элемент) выходит за границы текущего окна (т.е. i - k), удаляем его из дека.

* Добавление максимального значения в результат:

Когда индекс i становится больше или равен k - 1 (окно полностью сформировано), добавляем значение nums[windowIndices.front()] в вектор result. Это значение является максимальным в текущем окне.

* Итог:

Этот алгоритм использует дек (двустороннюю очередь) для хранения индексов элементов текущего окна и поддержания максимального элемента в начале дека. В результате, максимальный элемент каждого окна добавляется в вектор result, который и возвращается в конце выполнения функции.
