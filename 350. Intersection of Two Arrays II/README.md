https://leetcode.com/problems/intersection-of-two-arrays-ii/description/

https://en.cppreference.com/w/cpp/algorithm/set_intersection

[Разбор задачи 350 leetcode.com Intersection of Two Arrays II. Решение на C++](https://www.youtube.com/watch?v=QgsZ3BI1Xc8&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)

_______________

1. unordered_тар или самописная хэш-таблица.

unordered_map<int,int> - накладные расходы на одну пару ключ/значение ~ 24 байт - в 3 раза больше, сама пара.

Если в массиве все числа различные - то при занесении в unordered_тар разбухание в ~ б раз.

Самописная хэш-таблица: можем написать хэш-таблицу с открытым перемешиванием. Там разбухание будет в ~ 1.5 раза.

Можно разрешить: несколько одинаковых ключей - и не нужно будет хранить значение - сколько раз ключ встречался. Плохая алгоритмическая сложность.

Если хранить пары (число - количество), то разбухание будет в ~ 3 раза .

Алгоритм: сначала более короткий из массивов заносим в хэш-таблицу. Ключ - число из массива, значение - сколько раз встречалось. count[v]++.

Идём по более длинному массиву - ищем каждый его элемент в этой хэш-таблице. 
Если элемент есть и его количество не ноль - уменьшаем количество на 1, записываем это число в ответ

Сложность O(size(nums1) + size(nums2)) по времени,  
O(min(size(nums1), size(nums2))) по памяти.

Меньше нельзя - иначе не все элементы исходных массивов просмотрим.

Можно попробовать выиграть по времени...

2. Двоичный поиск.

На практике может обогнать unordered_map.

Сортируем массив меньшего размера. Формируем массив из пар (число, количество).

Идём по массиву большего размера - ищем двоичным 
поиском в меньшем массиве, если нашли и количество > 0 
- тогда уменьшаем количество, записываем число в ответ.

Разбухание всего в 2 раза.

Время: O((minSize + maxSize) * 1og(minSize))

Память: O(minSize)

3. Follo

