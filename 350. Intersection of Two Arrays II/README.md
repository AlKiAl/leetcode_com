https://leetcode.com/problems/intersection-of-two-arrays-ii/description/

https://en.cppreference.com/w/cpp/algorithm/set_intersection

[Разбор задачи 350 leetcode.com Intersection of Two Arrays II. Решение на C++](https://www.youtube.com/watch?v=QgsZ3BI1Xc8&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)

_______________

1. unordered_тар или самописная хэш-таблица.

unordered_map<int,int> - накладные расходы на одну пару ключ/значение ~ 24 байт - в 3 раза больше, сама пара.

Если в массиве все числа различные - то при занесении в unordered_тар разбухание в ~ б раз.

Самописная хэш-таблица: можем написать хэш-таблицу с открытым перемешиванием. Там разбухание будет в ~ 1.5 раза.

Можно разрешить: несколько одинаковых ключей - и не нужно будет хранить значение - сколько раз ключ встречался. Плохая алгоритмическая сложность.

Если хранить пары (число - количество), то разбухание будет в ~ 3 раза .

Алгоритм: сначала более короткий из массивов заносим в хэш-таблицу. Ключ - число из массива, значение - сколько раз встречалось. count[v]++.

Идём по более длинному массиву - ищем каждый его элемент в этой хэш-таблице. Если элемент есть и его количество не ноль - уменьшаем количество, записываем это число в ответ

