https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/

https://walkccc.me/LeetCode/problems/0121/

related:

[Разбор задачи 309 leetcode.com Best Time to Buy and Sell Stock with Cooldown. Решение на C++](https://www.youtube.com/watch?v=DLbTZhraubI&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)

[Разбор задачи 714 leetcode.com Best Time to Buy and Sell Stock with Transaction Fee. Решение на C++](https://www.youtube.com/watch?v=8whjaYFjBIk&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)
__________

[Разбор задачи 121 leetcode.com Best Time to Buy and Sell Stock. Решение на C++](https://www.youtube.com/watch?v=1SS2WnsMcbU&ab_channel=3.5%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%D0%B2%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E)

1. Наивный алгоритм. 

Перебираем дни, когда покупаем акцию i=0..n-1.

Для каждого дня покупки перебираем день продажи j=i+1..n-1.

Находим максимальную разность а[j]-а[i]. 

По времени O(n^2), по памяти O(1).

2. Улучшения.

зафиксируем или день покупки, или день продажи.

а) зафиксируем день продажи.
Тогда для макс разности нам нужно найти min из всех 
предыдущих элементов.

Когда обрабатываема[1] - нужен min(а[0])

Когда обрабатываема[2] - нужен min(а[0],а[1])

Когда обрабатываема[3] - нужен min(а[0],а[1],а[2])

следующий минимум получается из предыдущего.

O(n) по времени и O(1) по памяти.
Идём слева направо, поддерживаем минимум пройденных 
элементов, когда встречаем новый элемент - смотрим 
разность этого элемента и минимума предыдущих.

б) зафиксируем день покупки.
Тогда для макс разности нам нужно найти max из всех 
следующих элементов.

когда обрабатываем а[n-2] - нужен max(а[n-1]) --> Profit[n-2] = а[n-2] - max(а[n-1])

когда обрабатываем а[n-3] - нужен max(а[n-1],а[n-2]) --> Profit[n-3] = а[n-3] - max(а[n-1],а[n-2])

Искомое: max(Profit[n-2], Profit[n-3], ..., Profit[0])

Идём от конца массива, поддерживаем максимум 
пройденных элементов, встречаем новый - смотрим 
разность того максимума и этого элемента. Из всех 
разностей находим максимальную.

Меньше O(n) по времени нельзя, потому что иначе мы не 
посетим все элементы исходного массива.

Меньше O(1) по памяти нельзя.

__________

<p align="center"> два указателя </p>

<p align="center"> Example 1: </p>

prices = [7,1,5,3,6,4]

| i 	| _prices[i]_ 	| _MinPrice_ 	| **MaximumProfit** 	|
|:-:	|:-----------:	|:----------:	|:-----------------:	|
| 0 	|     _7_     	|     _7_    	|       **0**       	|
| 1 	|     _1_     	|     _1_    	|       **0**       	|
| 2 	|     _5_     	|     _1_    	|       **4**       	|
| 3 	|     _3_     	|     _1_    	|       **4**       	|
| 4 	|     _6_     	|     _1_    	|       **5**       	|
| 5 	|     _4_     	|     _1_    	|       **5**       	|

<p align="center"> Динамическое программирование </p>

<p align="center"> Example 1: </p>

prices = [7,1,5,3,6,4]

| i 	| _prices[i]_ 	| _maxPrices[i]_ 	| **MaximumProfit** 	|
|---	|-------------	|-------------	|-------------------	|
| 0 	| _7_         	| _7_         	| **0**             	|
| 1 	| _1_         	| _6_         	| **5**             	|
| 2 	| _5_         	| _6_         	| **1**             	|
| 3 	| _3_         	| _6_         	| **3**             	|
| 4 	| _6_         	| _6_         	| **0**             	|
| 5 	| _4_         	| _4_         	| **0**             	|



MaximumProfit = max{maxPrices[i] - prices[i] : 0 <= i <= prices.size() - 1}

maxPrices[i] - максимальная цена акции, по которой можно продать в i-ый день. 
Так как максимальная цена может быть достигнута в день d > i, надо заполнять этот контейнер справа налево  
maxPrices[i] = либо prices[i], либо maxPrices[i + 1] -- из этих значений берется максимум. 
То есть:  
либо максимальная цена была в день d > i --> maxPrices[i] = maxPrices[i + 1]  
либо максимальная цена в день i --> maxPrices[i] = prices[i]


<p align="center"> Example 2: </p>

| i 	| _prices[i]_ 	| _maxPrices_ 	| **MaximumProfit** 	|
|---	|-------------	|-------------	|-------------------	|
| 0 	| _7_         	| _7_         	| **0**             	|
| 1 	| _6_         	| _6_         	| **0**             	|
| 2 	| _4_         	| _4_         	| **0**             	|
| 3 	| _3_         	| _3_         	| **0**             	|
| 4 	| _1_         	| _1_         	| **0**             	|
